---
title: Java内存模型
date: 2016-10-02 11:49
tags: JVM
categories: JVM
---
由于CPU与存储器的运行速度差异的存在，需要引用**高速缓存**来解决。而引入高速缓存之后，又会带来缓存一致性的问题，即多个处理器有着自己的高速缓存，但却共用一个主存。

###**Java内存模型**
在Java虚拟机中是怎么解决上述问题的？先用一个图来引用Java的内存模型：
![Java内存模型](http://img.blog.csdn.net/20161001235233918)
<!--more-->
首先，对几个名词进行梳理：
**主内存**：Java内存模型中规定了所有的变量都必须存储在主内存中，可以类比硬件中的内存。
**工作内存**：每条线程都有自己**独立**（无法互相访问）的一个工作内存（可以类比高速缓存）工作内存中保存了**对被该线程使用到的变量的主内存的副本**，线程对变量的所有操作都必须在工作内存中进行，而不能直接读取主内存中的变量。

###**内存间交互操作**

一个变量如何从主存拷贝到工作内存，如何从工作内存同步到主存中？Java内存模型中定义了一下八种操作：

 - lock：作用于主存的变量，把变量标识为线程独占的状态。
 - unlock:给变量释放锁，释放后该变量才能被 其他线程锁定。
 - read：把一个变量值从主存传输到工作内存。以便load操作。
 - load：将read得到的变量值载入到工作内存的变量副本中。
 - use：将工作内存中一个变量的值传输到执行引擎。
 - assign：把执行引擎收到的值赋值给工作内存中的变量。
 - store：与read相反，把工作内存中的变量值传输到主存中。
 - write：将store得到的变量值载入到主存的变量中。
 
需要注意的是read与load，store与write需要顺序的执行。当然，Java内存模型在执行上述操作时也有一些规定：

 - 不允许read和load，store和write单独出现。
 - 不允许一个线程丢弃它最近的assign操作。变量在工作内存改变了必须同步会主存中。
 - 不允许线程无原因地同步变量到主存中。
 - 执行use和store之前，必须先执行assign和load操作。
 - 一个变量在同一时刻只允许一个线程执行lock操作。一个线程可以执行多次lock操作，但是要执行相同次数的unlock操作才能解锁。
 - 如果对一个变量执行lock操作，工作内存中此变量的值会被清空。
 - 如果没有执行过lock操作，则不能执行unlock操作。
 - 对一个变量执行unlock操作前，必须通过store和write操作同步此变量到主存中。